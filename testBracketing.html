<html>
<head>

  <script src="//cdnjs.cloudflare.com/ajax/libs/three.js/r69/three.js"></script>
  <script src="//js.leapmotion.com/leap-0.6.3.js"></script>
  <script src="//js.leapmotion.com/leap-plugins-0.1.9.min.js"></script>

  <!-- include boneHand from master. Fixes a super janky issue where only one hand would appear when
       using deferred scene creation, which we do here -->
  <script src="javascript/lib/leap.bone-hand.js"></script>
  <script src="javascript/lib/leap.bracketRecognizer.js"></script>

  <script src="javascript/lib/VRControls.js"></script>
  <script src="javascript/lib/VREffect.js"></script>

  <style>
    body {
      margin: 0;
    }
  </style>

</head>
<body>

<canvas id="scene"></canvas>

</body>

<script>

  // Set up plugins

  Leap.loop()
    .use('transform', {
      vr: true
    })
    .use('boneHand', {
      targetEl: document.body,
      arm: true
    })
    .use('handBrackets');

  var transform = Leap.loopController.plugins.transform;
  var boneHand  = Leap.loopController.plugins.boneHand;
  transform.effectiveParent = boneHand.camera;
  scene = boneHand.scene;

  vrEffect   = new THREE.VREffect(boneHand.renderer);
  vrControls = new THREE.VRControls(boneHand.camera);

  boneHand.render = function(){
    vrControls.update();
    vrEffect.render(this.scene, this.camera);
  };

  var onkey = function(event) {
    if (event.key === 'z') {
      vrControls.zeroSensor();
    }
    if (event.key === 'f') {
      return vrEffect.setFullScreen(true);
    }
  };

  window.addEventListener("keypress", onkey, true);


  var cubeGeo = new THREE.BoxGeometry(0.032, 0.032, 0.032);
  var cubeMesh = new THREE.MeshPhongMaterial({color: 0x00cc00});

  // forwards
  var cube = new THREE.Mesh(cubeGeo, cubeMesh);
  cube.position.set(-0.06,-0.03,-0.3);
  scene.add(cube);

  cube = new THREE.Mesh(cubeGeo, cubeMesh);
  cube.position.set(0.06,-0.03,-0.3);
  scene.add(cube);

  cube = new THREE.Mesh(cubeGeo, cubeMesh);
  cube.position.set(-0.06,-0.03,-0.42);
  scene.add(cube);

  cube = new THREE.Mesh(cubeGeo, cubeMesh);
  cube.position.set(0.06,-0.03,-0.42);
  scene.add(cube);


  // right
  cubeMesh = new THREE.MeshPhongMaterial({color: 0x0000cc});

  cube = new THREE.Mesh(cubeGeo, cubeMesh);
  cube.position.set(0.3,-0.03,-0.06);
  scene.add(cube);

  cube = new THREE.Mesh(cubeGeo, cubeMesh);
  cube.position.set(0.3,-0.03,0.06);
  scene.add(cube);

  cube = new THREE.Mesh(cubeGeo, cubeMesh);
  cube.position.set(0.42,-0.03,-0.06);
  scene.add(cube);

  cube = new THREE.Mesh(cubeGeo, cubeMesh);
  cube.position.set(0.42,-0.03,0.06);
  scene.add(cube);

  // left
  cubeMesh = new THREE.MeshPhongMaterial({color: 0xcc0000});

  cube = new THREE.Mesh(cubeGeo, cubeMesh);
  cube.position.set(-0.3,-0.03,-0.06);
  scene.add(cube);

  cube = new THREE.Mesh(cubeGeo, cubeMesh);
  cube.position.set(-0.3,-0.03,0.06);
  scene.add(cube);

  cube = new THREE.Mesh(cubeGeo, cubeMesh);
  cube.position.set(-0.42,-0.03,-0.06);
  scene.add(cube);

  cube = new THREE.Mesh(cubeGeo, cubeMesh);
  cube.position.set(-0.42,-0.03,0.06);
  scene.add(cube);


  // back
  cubeMesh = new THREE.MeshPhongMaterial({color: 0xcccc00});

  cube = new THREE.Mesh(cubeGeo, cubeMesh);
  cube.position.set(-0.06,-0.03,0.3);
  scene.add(cube);

  cube = new THREE.Mesh(cubeGeo, cubeMesh);
  cube.position.set(0.06,-0.03,0.3);
  scene.add(cube);

  cube = new THREE.Mesh(cubeGeo, cubeMesh);
  cube.position.set(-0.06,-0.03,0.42);
  scene.add(cube);

  cube = new THREE.Mesh(cubeGeo, cubeMesh);
  cube.position.set(0.06,-0.03,0.42);
  scene.add(cube);



</script>

</html>